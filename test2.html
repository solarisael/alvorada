<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Text Effects Lab (Qud-ish)</title>
  <style>
    :root {
      --bg: #0b0f10;
      --panel: #10181a;
      --panel2: #0e1416;
      --border: #1e2a2e;
      --text: #d8f2e1;
      --muted: #86a19a;

      --fg: #d8f2e1;
      --bg2: #0b0f10;
      --accent: #37e5a3;

      --intensity: 0.65;
      --speed: 1.0;
      --glitch: 10px;
      --blur: 0px;
      --spread: 18px;
      --scan-opacity: 0.16;

      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius: 14px;
      --shadow: 0 10px 30px rgba(0, 0, 0, .35);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(55, 229, 163, .10), transparent 60%),
        radial-gradient(900px 600px at 90% 90%, rgba(80, 170, 255, .10), transparent 60%),
        linear-gradient(180deg, #070a0b, #0b0f10 55%, #080b0c);
      color: var(--text);
    }

    .row {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card {
      background: color-mix(in oklab, var(--panel) 82%, transparent);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .pad {
      padding: 16px;
    }

    .btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #2a3a40;
      background: linear-gradient(180deg, #10181a, #0b1113);
      color: var(--text);
      cursor: pointer;
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
      user-select: none;
    }

    .btn:hover {
      border-color: #3b545d;
      filter: brightness(1.06);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn.primary {
      border-color: color-mix(in oklab, var(--accent) 55%, #2a3a40);
      background: linear-gradient(180deg, color-mix(in oklab, var(--accent) 18%, #111a1c), #0a1112);
    }

    .tag {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid #24343a;
      color: color-mix(in oklab, var(--muted) 80%, #9fb9b2);
      background: rgba(0, 0, 0, .25);
    }

    .wrap {
      height: 100%;
      display: grid;
      grid-template-columns: 410px 1fr;
      gap: 14px;
      padding: 14px;
    }

    @media (max-width: 980px) {
      .wrap {
        grid-template-columns: 1fr;
        height: auto;
        min-height: 100%;
      }
    }

    .header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: 14px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: color-mix(in oklab, var(--muted) 80%, #b7d6cc);
    }

    .sub {
      margin: 6px 0 0;
      font-size: 12px;
      color: color-mix(in oklab, var(--muted) 80%, #b7d6cc);
      line-height: 1.35;
    }

    label {
      font-size: 12px;
      color: color-mix(in oklab, var(--muted) 85%, #cde7dc);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 0;
      user-select: none;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      font-family: var(--font);
      color: var(--text);
      background: color-mix(in oklab, var(--panel2) 85%, transparent);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, .03);
    }

    textarea {
      min-height: 88px;
      resize: vertical;
    }

    input[type="range"] {
      width: 100%;
    }

    input[type="color"] {
      width: 42px;
      height: 28px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .grid3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    .checks {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 6px;
    }

    .check {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid #213037;
      border-radius: 12px;
      background: rgba(0, 0, 0, .18);
    }

    .check:hover {
      border-color: #2f4650;
    }

    .check input {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    .check span {
      font-size: 12px;
      color: color-mix(in oklab, var(--muted) 92%, #e6fff4);
    }

    .preview-card {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 360px;
    }

    .preview-shell {
      position: relative;
      flex: 1;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(0, 0, 0, .22), rgba(0, 0, 0, .35));
      overflow: hidden;
    }

    .stage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 34px;
    }

    .preview {
      position: relative;
      display: inline-block;
      font-size: clamp(22px, 3.2vw, 62px);
      line-height: 1.06;
      letter-spacing: .01em;
      color: var(--fg);
      text-shadow: none;
      filter: none;
      transform: translateZ(0);
      will-change: transform, filter, text-shadow;
      white-space: pre-wrap;
      text-align: center;
      max-width: min(980px, 100%);
    }

    /* ===== Multicolor-per-letter effect =====
       JS will wrap letters in <span class="ql"> and set style="--lc:#hex"
       This effect turns the base text color transparent and uses each letter's --lc.
    */
    .fx-perletter {
      color: transparent;
      text-shadow: none;
    }

    .fx-perletter .ql {
      color: var(--lc, var(--fg));
      display: inline-block;
      will-change: transform, filter;
    }

    /* When combined with gradient/rainbow, per-letter should win */
    .fx-perletter.fx-rainbow,
    .fx-perletter.fx-gradient {
      background: none !important;
      -webkit-background-clip: initial !important;
      background-clip: initial !important;
      color: transparent !important;
    }

    /* === EFFECTS === */
    .fx-smooth {
      text-rendering: geometricPrecision;
    }

    .fx-tight {
      letter-spacing: -0.02em;
    }

    .fx-wide {
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .fx-neon {
      text-shadow:
        0 0 calc(var(--spread) * .25) color-mix(in oklab, var(--accent) 75%, transparent),
        0 0 calc(var(--spread) * .55) color-mix(in oklab, var(--accent) 55%, transparent),
        0 0 calc(var(--spread) * 1.15) color-mix(in oklab, var(--accent) 35%, transparent);
      filter: saturate(1.1);
    }

    .fx-glow {
      text-shadow:
        0 0 calc(var(--spread) * .22) color-mix(in oklab, var(--fg) 70%, transparent),
        0 0 calc(var(--spread) * .5) color-mix(in oklab, var(--fg) 35%, transparent);
    }

    .fx-blur {
      filter: blur(var(--blur));
    }

    .fx-outline {
      -webkit-text-stroke: max(1px, calc(1px + (var(--intensity) * 1.2px))) color-mix(in oklab, var(--accent) 60%, #000);
      paint-order: stroke fill;
    }

    .fx-shadow {
      text-shadow:
        2px 2px 0 rgba(0, 0, 0, .65),
        4px 4px 0 rgba(0, 0, 0, .35);
    }

    .fx-chroma {
      text-shadow:
        calc(var(--intensity) * -2px) 0 0 rgba(255, 60, 120, .75),
        calc(var(--intensity) * 2px) 0 0 rgba(80, 200, 255, .75);
    }

    .fx-glitch {
      position: relative;
    }

    .fx-glitch::before,
    .fx-glitch::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: .9;
      color: var(--fg);
    }

    .fx-glitch::before {
      color: rgba(255, 80, 120, .9);
      transform: translate(calc(var(--glitch) * -0.15), 0);
      clip-path: inset(0 0 0 0);
      animation: glitchTop calc(1.15s / var(--speed)) infinite steps(2, end);
      text-shadow: 0 0 10px rgba(255, 80, 120, .25);
    }

    .fx-glitch::after {
      color: rgba(80, 220, 255, .9);
      transform: translate(calc(var(--glitch) * 0.15), 0);
      clip-path: inset(0 0 0 0);
      animation: glitchBot calc(0.95s / var(--speed)) infinite steps(2, end);
      text-shadow: 0 0 10px rgba(80, 220, 255, .25);
    }

    @keyframes glitchTop {
      0% {
        clip-path: inset(0 0 85% 0);
        transform: translate(calc(var(--glitch) * -0.1), calc(var(--glitch) * -0.05));
      }

      10% {
        clip-path: inset(0 0 65% 0);
      }

      20% {
        clip-path: inset(0 0 78% 0);
        transform: translate(calc(var(--glitch) * -0.2), 0);
      }

      30% {
        clip-path: inset(0 0 55% 0);
      }

      40% {
        clip-path: inset(0 0 72% 0);
        transform: translate(calc(var(--glitch) * 0.08), calc(var(--glitch) * -0.08));
      }

      55% {
        clip-path: inset(0 0 60% 0);
      }

      70% {
        clip-path: inset(0 0 80% 0);
        transform: translate(calc(var(--glitch) * -0.12), calc(var(--glitch) * 0.06));
      }

      100% {
        clip-path: inset(0 0 85% 0);
        transform: translate(calc(var(--glitch) * -0.1), calc(var(--glitch) * -0.05));
      }
    }

    @keyframes glitchBot {
      0% {
        clip-path: inset(85% 0 0 0);
        transform: translate(calc(var(--glitch) * 0.12), calc(var(--glitch) * 0.06));
      }

      12% {
        clip-path: inset(65% 0 0 0);
      }

      24% {
        clip-path: inset(78% 0 0 0);
        transform: translate(calc(var(--glitch) * 0.22), 0);
      }

      36% {
        clip-path: inset(55% 0 0 0);
      }

      48% {
        clip-path: inset(72% 0 0 0);
        transform: translate(calc(var(--glitch) * -0.06), calc(var(--glitch) * 0.08));
      }

      62% {
        clip-path: inset(60% 0 0 0);
      }

      78% {
        clip-path: inset(80% 0 0 0);
        transform: translate(calc(var(--glitch) * 0.14), calc(var(--glitch) * -0.05));
      }

      100% {
        clip-path: inset(85% 0 0 0);
        transform: translate(calc(var(--glitch) * 0.12), calc(var(--glitch) * 0.06));
      }
    }

    .fx-wiggle {
      animation: wiggle calc(1.2s / var(--speed)) infinite ease-in-out;
    }

    @keyframes wiggle {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      25% {
        transform: translateY(calc(var(--intensity) * -2px)) rotate(calc(var(--intensity) * -0.6deg));
      }

      50% {
        transform: translateY(calc(var(--intensity) * 2px)) rotate(calc(var(--intensity) * 0.6deg));
      }

      75% {
        transform: translateY(calc(var(--intensity) * -1px)) rotate(calc(var(--intensity) * 0.4deg));
      }
    }

    .fx-float {
      animation: floaty calc(2.8s / var(--speed)) infinite ease-in-out;
    }

    @keyframes floaty {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(calc(var(--intensity) * -10px));
      }
    }

    .fx-shake {
      animation: shake calc(0.5s / var(--speed)) infinite steps(2, end);
    }

    @keyframes shake {
      0% {
        transform: translate(0, 0);
      }

      25% {
        transform: translate(calc(var(--intensity) * 2px), calc(var(--intensity) * -1px));
      }

      50% {
        transform: translate(calc(var(--intensity) * -2px), calc(var(--intensity) * 1px));
      }

      75% {
        transform: translate(calc(var(--intensity) * 1px), calc(var(--intensity) * 2px));
      }

      100% {
        transform: translate(0, 0);
      }
    }

    .fx-flicker {
      animation: flicker calc(1.6s / var(--speed)) infinite linear;
    }

    @keyframes flicker {

      0%,
      100% {
        opacity: 1;
        filter: brightness(1);
      }

      3% {
        opacity: .85;
      }

      6% {
        opacity: 1;
      }

      8% {
        opacity: .75;
        filter: brightness(1.15);
      }

      10% {
        opacity: 1;
      }

      40% {
        opacity: .92;
      }

      42% {
        opacity: 1;
      }

      85% {
        opacity: .8;
      }

      87% {
        opacity: 1;
      }
    }

    .fx-rainbow {
      background: linear-gradient(90deg,
          #ff4d6d, #ffb703, #8aff80, #4cc9f0, #9b5de5, #ff4d6d);
      background-size: 300% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: rainbow calc(3.2s / var(--speed)) linear infinite;
      text-shadow: none;
    }

    @keyframes rainbow {
      0% {
        background-position: 0% 50%;
      }

      100% {
        background-position: 100% 50%;
      }
    }

    .fx-gradient {
      background: linear-gradient(90deg,
          color-mix(in oklab, var(--fg) 90%, #fff),
          color-mix(in oklab, var(--accent) 95%, #fff),
          color-mix(in oklab, var(--fg) 90%, #fff));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .fx-type {
      --chars: 28;
      display: inline-block;
      overflow: hidden;
      border-right: 2px solid color-mix(in oklab, var(--accent) 80%, transparent);
      white-space: nowrap;
      animation:
        typing calc((var(--chars) * 0.08s) / var(--speed)) steps(var(--chars), end) 1 both,
        caret calc(0.7s / var(--speed)) steps(1, end) infinite;
    }

    @keyframes typing {
      from {
        width: 0;
      }

      to {
        width: min(100%, calc(var(--chars) * 0.62em));
      }
    }

    @keyframes caret {
      50% {
        border-color: transparent;
      }
    }

    .crt::before {
      content: "";
      position: absolute;
      inset: -40px;
      pointer-events: none;
      background:
        radial-gradient(1200px 900px at 50% 50%, rgba(255, 255, 255, .06), transparent 60%),
        linear-gradient(180deg,
          rgba(255, 255, 255, calc(var(--scan-opacity) * .10)),
          rgba(0, 0, 0, calc(var(--scan-opacity) * .25))),
        repeating-linear-gradient(180deg,
          rgba(0, 0, 0, calc(var(--scan-opacity) * .22)) 0px,
          rgba(0, 0, 0, calc(var(--scan-opacity) * .22)) 1px,
          rgba(255, 255, 255, calc(var(--scan-opacity) * .02)) 2px,
          rgba(0, 0, 0, 0) 4px);
      mix-blend-mode: overlay;
      opacity: .9;
      transform: perspective(900px) rotateX(0.4deg) rotateY(-0.25deg);
      filter: contrast(1.05) saturate(1.06);
    }

    .crt::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(120% 90% at 50% 50%,
          transparent 40%,
          rgba(0, 0, 0, .35) 80%,
          rgba(0, 0, 0, .55) 100%);
      opacity: .85;
    }

    .crt .stage {
      transform: perspective(1200px) scale(1.01);
      filter: contrast(1.02) saturate(1.04);
    }

    .fx-pixel {
      filter: contrast(1.1);
      text-shadow: 1px 0 0 rgba(0, 0, 0, .45), 0 1px 0 rgba(0, 0, 0, .45);
    }

    .fx-smear {
      text-shadow:
        calc(var(--intensity) * -6px) 0 0 rgba(0, 0, 0, .25),
        calc(var(--intensity) * -12px) 0 0 rgba(0, 0, 0, .18),
        calc(var(--intensity) * -18px) 0 0 rgba(0, 0, 0, .12);
    }

    .mini {
      font-size: 12px;
      color: color-mix(in oklab, var(--muted) 80%, #b7d6cc);
      line-height: 1.35;
    }

    .split {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .pill {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #24343a;
      background: rgba(0, 0, 0, .22);
      color: color-mix(in oklab, var(--muted) 90%, #e6fff4);
    }

    .code {
      width: 100%;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre;
      overflow: auto;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #213037;
      background: rgba(0, 0, 0, .28);
      color: color-mix(in oklab, var(--text) 92%, #fff);
      max-height: 180px;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .swatch {
      width: 28px;
      height: 22px;
      border-radius: 10px;
      border: 1px solid #25353b;
      cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, .06);
      position: relative;
      background: #000;
    }

    .swatch::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 10px;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, .22) inset;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card pad col">
      <div class="header">
        <div>
          <h1>Text Effects Lab</h1>
          <p class="sub">Now includes <span class="pill">Per-letter palette</span> (each glyph can be a different
            color).</p>
        </div>
        <div class="tag" id="status">LIVE</div>
      </div>

      <div class="col">
        <label>
          <span>Text</span>
          <span class="tag" id="charInfo">0 chars</span>
        </label>
        <textarea id="txt" spellcheck="false">THE STAR-SHELL HUMS
IN GLASSY NEON</textarea>
      </div>

      <div class="grid2">
        <div class="col">
          <label>
            <span>Foreground</span>
            <span class="row">
              <span class="pill" id="fgHex">#d8f2e1</span>
              <input id="fg" type="color" value="#d8f2e1" />
            </span>
          </label>
        </div>
        <div class="col">
          <label>
            <span>Accent</span>
            <span class="row">
              <span class="pill" id="acHex">#37e5a3</span>
              <input id="accent" type="color" value="#37e5a3" />
            </span>
          </label>
        </div>
      </div>

      <div class="grid2">
        <div class="col">
          <label>
            <span>Background</span>
            <span class="row">
              <span class="pill" id="bgHex">#0b0f10</span>
              <input id="bg" type="color" value="#0b0f10" />
            </span>
          </label>
        </div>
        <div class="col">
          <label>
            <span>Preset Palette</span>
            <select id="paletteSelect">
              <option value="qud-emerald" selected>Qud-ish Emerald</option>
              <option value="qud-amber">Qud-ish Amber</option>
              <option value="qud-cyan">Qud-ish Cyan</option>
              <option value="qud-magenta">Qud-ish Magenta</option>
              <option value="mono-green">Mono Green</option>
              <option value="mono-amber">Mono Amber</option>
              <option value="ice">Ice</option>
              <option value="blood">Blood</option>
              <option value="void">Void</option>
              <option value="custom">Custom (no changes)</option>
            </select>
          </label>
        </div>
      </div>

      <div class="col">
        <label><span>Quick Swatches</span><span class="tag">click to set Accent</span></label>
        <div class="palette" id="swatches"></div>
      </div>

      <div class="grid2">
        <div class="col">
          <label><span>Intensity</span><span class="pill" id="intVal">0.65</span></label>
          <input id="intensity" type="range" min="0" max="1" value="0.65" step="0.01" />
        </div>
        <div class="col">
          <label><span>Speed</span><span class="pill" id="spdVal">1.00×</span></label>
          <input id="speed" type="range" min="0.2" max="3" value="1" step="0.01" />
        </div>
      </div>

      <div class="grid3">
        <div class="col">
          <label><span>Glitch</span><span class="pill" id="glVal">10px</span></label>
          <input id="glitch" type="range" min="0" max="40" value="10" step="1" />
        </div>
        <div class="col">
          <label><span>Blur</span><span class="pill" id="blVal">0px</span></label>
          <input id="blur" type="range" min="0" max="12" value="0" step="0.25" />
        </div>
        <div class="col">
          <label><span>Glow</span><span class="pill" id="spVal">18px</span></label>
          <input id="spread" type="range" min="0" max="40" value="18" step="1" />
        </div>
      </div>

      <div class="grid2">
        <div class="col">
          <label>
            <span>Per-letter palette</span>
            <select id="letterPalette">
              <option value="none" selected>Off</option>
              <option value="qudCycle">Qud Cycle</option>
              <option value="terminalWarm">Terminal Warm</option>
              <option value="acidCandy">Acid Candy</option>
              <option value="voidBloom">Void Bloom</option>
              <option value="iceFire">Ice & Fire</option>
              <option value="randomPerChar">Random (per char)</option>
              <option value="randomPerWord">Random (per word)</option>
            </select>
          </label>
        </div>
        <div class="col">
          <label><span>Cycle mode</span>
            <select id="letterMode">
              <option value="cycle" selected>Cycle (repeat)</option>
              <option value="gradient">Gradient-like (smooth)</option>
            </select>
          </label>
        </div>
      </div>

      <div class="grid2">
        <div class="col">
          <label><span>Letter jitter</span><span class="pill" id="jitVal">0px</span></label>
          <input id="letterJitter" type="range" min="0" max="6" value="0" step="0.25" />
        </div>
        <div class="col">
          <label><span>Letter anim</span><span class="pill" id="lanVal">0.00</span></label>
          <input id="letterAnim" type="range" min="0" max="1" value="0" step="0.01" />
        </div>
      </div>

      <div class="col">
        <label><span>Effects (stackable)</span><span class="tag">toggle</span></label>
        <div class="checks" id="effects"></div>
      </div>

      <div class="split">
        <button class="btn primary" id="copyCss">Copy CSS</button>
        <button class="btn" id="copyHtml">Copy HTML</button>
        <button class="btn" id="randomize">Randomize</button>
        <span class="pill" id="copied" style="display:none;">Copied</span>
      </div>

      <div class="col">
        <label><span>Snippet Preview</span><span class="tag">your current stack</span></label>
        <pre class="code" id="snippet"></pre>
      </div>
    </div>

    <div class="card pad preview-card">
      <div class="split">
        <div class="row">
          <span class="tag">Preview</span>
          <span class="pill" id="classList">classes: —</span>
        </div>
        <div class="row">
          <span class="tag">Theme</span>
          <span class="pill" id="themeInfo">fg / accent / bg</span>
        </div>
      </div>

      <div class="preview-shell" id="shell">
        <div class="stage">
          <div id="preview" class="preview fx-smooth" data-text=""></div>
        </div>
      </div>

      <div class="mini">
        Turn on <span class="pill">Per-letter palette</span> and optionally add <span class="pill">Neon</span> or <span
          class="pill">Glitch</span>.
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const el = {
      txt: $("txt"),
      preview: $("preview"),
      shell: $("shell"),
      status: $("status"),
      charInfo: $("charInfo"),

      fg: $("fg"),
      accent: $("accent"),
      bg: $("bg"),
      fgHex: $("fgHex"),
      acHex: $("acHex"),
      bgHex: $("bgHex"),

      paletteSelect: $("paletteSelect"),
      swatches: $("swatches"),

      intensity: $("intensity"),
      speed: $("speed"),
      glitch: $("glitch"),
      blur: $("blur"),
      spread: $("spread"),

      intVal: $("intVal"),
      spdVal: $("spdVal"),
      glVal: $("glVal"),
      blVal: $("blVal"),
      spVal: $("spVal"),

      effects: $("effects"),
      classList: $("classList"),
      themeInfo: $("themeInfo"),

      snippet: $("snippet"),
      copyCss: $("copyCss"),
      copyHtml: $("copyHtml"),
      copied: $("copied"),
      randomize: $("randomize"),

      letterPalette: $("letterPalette"),
      letterMode: $("letterMode"),
      letterJitter: $("letterJitter"),
      letterAnim: $("letterAnim"),
      jitVal: $("jitVal"),
      lanVal: $("lanVal"),
    };

    const EFFECTS = [
      { id: "fx-neon", label: "Neon" },
      { id: "fx-glow", label: "Glow" },
      { id: "fx-blur", label: "Blur" },
      { id: "fx-outline", label: "Outline" },
      { id: "fx-shadow", label: "Shadow" },
      { id: "fx-chroma", label: "Chroma" },
      { id: "fx-glitch", label: "Glitch" },
      { id: "fx-wiggle", label: "Wiggle" },
      { id: "fx-float", label: "Float" },
      { id: "fx-shake", label: "Shake" },
      { id: "fx-flicker", label: "Flicker" },
      { id: "fx-rainbow", label: "Rainbow" },
      { id: "fx-gradient", label: "Gradient" },
      { id: "fx-type", label: "Typewriter" },
      { id: "fx-pixel", label: "Pixel-ish" },
      { id: "fx-smear", label: "Smear" },
      { id: "fx-wide", label: "Wide" },
      { id: "fx-tight", label: "Tight" },
      { id: "crt", label: "CRT Overlay (container)", target: "shell" },
      { id: "fx-perletter", label: "Per-letter Colors" }, // NEW
    ];

    const DEFAULT_ON = new Set(["fx-neon", "fx-glow", "crt"]);

    const PALETTES = {
      "qud-emerald": { fg: "#d8f2e1", accent: "#37e5a3", bg: "#0b0f10" },
      "qud-amber": { fg: "#ffe8c7", accent: "#ffb703", bg: "#100d08" },
      "qud-cyan": { fg: "#d7fbff", accent: "#4cc9f0", bg: "#071014" },
      "qud-magenta": { fg: "#ffe0ff", accent: "#ff4dcd", bg: "#120715" },
      "mono-green": { fg: "#b7ffcf", accent: "#24f5a8", bg: "#060a08" },
      "mono-amber": { fg: "#ffe2b4", accent: "#ffb45a", bg: "#0c0906" },
      "ice": { fg: "#e8f6ff", accent: "#88c7ff", bg: "#05080d" },
      "blood": { fg: "#ffe2e2", accent: "#ff3d3d", bg: "#120606" },
      "void": { fg: "#d6d6ff", accent: "#9b5de5", bg: "#07060e" },
      "custom": null
    };

    const SWATCHES = [
      "#37e5a3", "#24f5a8", "#4cc9f0", "#88c7ff", "#9b5de5", "#ff4dcd",
      "#ff4d6d", "#ff3d3d", "#ffb703", "#ffd166", "#8aff80", "#7ae582",
      "#b7ffcf", "#ffe2b4", "#d7fbff", "#ffe0ff"
    ];

    // Array-of-palettes (each entry is an array of colors) for per-letter effect
    const LETTER_PALETTES = {
      qudCycle: [
        ["#37e5a3", "#24f5a8", "#4cc9f0", "#88c7ff", "#9b5de5", "#ff4dcd", "#ff4d6d", "#ffb703"],
        ["#b7ffcf", "#d7fbff", "#ffe0ff", "#ffe2b4", "#8aff80", "#4cc9f0"],
        ["#ffb703", "#ffd166", "#ffe2b4", "#b7ffcf", "#24f5a8"]
      ],
      terminalWarm: [
        ["#ffb703", "#ffd166", "#ffe2b4", "#ffe8c7", "#ff4d6d"],
        ["#ffb45a", "#ffd166", "#ffe2b4", "#b7ffcf"]
      ],
      acidCandy: [
        ["#ff4dcd", "#9b5de5", "#4cc9f0", "#8aff80", "#ffb703", "#ff4d6d"],
        ["#00f5d4", "#f15bb5", "#9b5de5", "#fee440", "#00bbf9"]
      ],
      voidBloom: [
        ["#d6d6ff", "#9b5de5", "#6c63ff", "#4cc9f0", "#37e5a3"],
        ["#ffe0ff", "#9b5de5", "#4cc9f0", "#d7fbff"]
      ],
      iceFire: [
        ["#d7fbff", "#88c7ff", "#4cc9f0", "#ffe2b4", "#ffb703", "#ff4d6d", "#ff3d3d"],
        ["#e8f6ff", "#88c7ff", "#ffb703", "#ff4d6d"]
      ],
      randomPerChar: [
        ["#37e5a3", "#24f5a8", "#4cc9f0", "#88c7ff", "#9b5de5", "#ff4dcd", "#ff4d6d", "#ffb703", "#ffd166", "#8aff80", "#b7ffcf", "#ffe2b4", "#d7fbff", "#ffe0ff"]
      ],
      randomPerWord: [
        ["#37e5a3", "#24f5a8", "#4cc9f0", "#88c7ff", "#9b5de5", "#ff4dcd", "#ff4d6d", "#ffb703", "#ffd166", "#8aff80", "#b7ffcf", "#ffe2b4", "#d7fbff", "#ffe0ff"]
      ]
    };

    function setCSSVar(k, v) { document.documentElement.style.setProperty(k, v); }
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function initEffectsUI() {
      const frag = document.createDocumentFragment();
      EFFECTS.forEach((fx) => {
        const wrap = document.createElement("label");
        wrap.className = "check";
        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = fx.id;
        input.checked = DEFAULT_ON.has(fx.id) || fx.id === "fx-perletter" ? false : false;
        if (fx.id === "fx-perletter") input.checked = false;
        input.addEventListener("change", applyAll);

        const span = document.createElement("span");
        span.textContent = fx.label;

        wrap.appendChild(input);
        wrap.appendChild(span);
        frag.appendChild(wrap);
      });
      el.effects.appendChild(frag);
    }

    function initSwatches() {
      const frag = document.createDocumentFragment();
      SWATCHES.forEach((hex) => {
        const b = document.createElement("button");
        b.className = "swatch";
        b.type = "button";
        b.style.background = hex;
        b.title = hex;
        b.addEventListener("click", () => {
          el.accent.value = hex;
          applyAll();
        });
        frag.appendChild(b);
      });
      el.swatches.appendChild(frag);
    }

    function getChecked() {
      const inputs = el.effects.querySelectorAll('input[type="checkbox"]');
      const out = { preview: [], shell: [] };
      inputs.forEach(i => {
        if (!i.checked) return;
        const fx = EFFECTS.find(x => x.id === i.value);
        if (fx && fx.target === "shell") out.shell.push(i.value);
        else out.preview.push(i.value);
      });
      return out;
    }

    function applyPalette(key) {
      const p = PALETTES[key];
      if (!p) return;
      el.fg.value = p.fg;
      el.accent.value = p.accent;
      el.bg.value = p.bg;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }
    function escapeAttr(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll('"', "&quot;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function lerp(a, b, t) { return a + (b - a) * t; }
    function hexToRgb(hex) {
      const h = hex.replace("#", "").trim();
      const n = parseInt(h.length === 3 ? h.split("").map(x => x + x).join("") : h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgbToHex({ r, g, b }) {
      const to = (x) => x.toString(16).padStart(2, "0");
      return "#" + to(clamp(Math.round(r), 0, 255)) + to(clamp(Math.round(g), 0, 255)) + to(clamp(Math.round(b), 0, 255));
    }
    function mixHex(a, b, t) {
      const A = hexToRgb(a), B = hexToRgb(b);
      return rgbToHex({ r: lerp(A.r, B.r, t), g: lerp(A.g, B.g, t), b: lerp(A.b, B.b, t) });
    }

    function buildPerLetterHTML(text, paletteKey, mode, jitterPx, animAmt) {
      const key = paletteKey;
      if (key === "none" || !LETTER_PALETTES[key]) return null;

      const paletteChoices = LETTER_PALETTES[key];
      const chosenPalette = pick(paletteChoices);

      const isRandomChar = key === "randomPerChar";
      const isRandomWord = key === "randomPerWord";

      // For random per word, assign a color per word index
      const words = text.split(/(\s+)/); // keep whitespace segments
      let wordColorMap = [];
      if (isRandomWord) {
        wordColorMap = words.map(seg => {
          if (/^\s+$/.test(seg)) return null;
          return pick(chosenPalette);
        });
      }

      let globalIndex = 0;
      let wordIdx = 0;

      const spans = [];
      const totalChars = Math.max(1, text.replace(/\r/g, "").length);

      const nextColor = (charIndex, withinWord) => {
        if (isRandomChar) return pick(chosenPalette);
        if (isRandomWord) {
          const c = wordColorMap[wordIdx] || pick(chosenPalette);
          return c;
        }

        if (mode === "gradient") {
          // Smooth-ish: map across chosenPalette endpoints
          if (chosenPalette.length === 1) return chosenPalette[0];
          const t = (totalChars <= 1) ? 0 : (charIndex / (totalChars - 1));
          const seg = t * (chosenPalette.length - 1);
          const i = Math.floor(seg);
          const f = seg - i;
          const c1 = chosenPalette[i];
          const c2 = chosenPalette[Math.min(i + 1, chosenPalette.length - 1)];
          return mixHex(c1, c2, f);
        }

        // Cycle
        return chosenPalette[charIndex % chosenPalette.length];
      };

      // Animation: optional subtle per-letter float using inline style delay
      const useAnim = animAmt > 0.001;
      const maxJ = Math.max(0, jitterPx);

      for (let i = 0; i < words.length; i++) {
        const seg = words[i];
        if (/^\s+$/.test(seg)) {
          spans.push(escapeHtml(seg));
          continue;
        }

        const chars = Array.from(seg);
        for (const ch of chars) {
          const color = nextColor(globalIndex, true);

          // jitter: tiny random offsets (static)
          const jx = maxJ ? (Math.random() * 2 - 1) * maxJ : 0;
          const jy = maxJ ? (Math.random() * 2 - 1) * maxJ : 0;

          // anim: sinusoidal bobble via CSS keyframes on span? (we'll inline animation with delay)
          const delay = (globalIndex * 0.03) % 1.2;

          const styleParts = [
            `--lc:${color};`,
            maxJ ? `transform: translate(${jx.toFixed(2)}px, ${jy.toFixed(2)}px);` : "",
            useAnim ? `animation: lBob ${(2.2 / parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--speed") || "1")).toFixed(3)}s ease-in-out ${delay.toFixed(2)}s infinite; animation-play-state: running;` : ""
          ].filter(Boolean).join(" ");

          spans.push(`<span class="ql" style="${styleParts}">${escapeHtml(ch)}</span>`);
          globalIndex++;
        }
        wordIdx++;
      }

      return spans.join("");
    }

    // Per-letter animation keyframes injected once
    (function ensureLetterAnimCSS() {
      const s = document.createElement("style");
      s.textContent = `
        @keyframes lBob{
          0%,100%{ transform: translate(var(--tx,0px), var(--ty,0px)) translateY(0); }
          50%{ transform: translate(var(--tx,0px), var(--ty,0px)) translateY(calc(-6px * var(--intensity))); }
        }
      `;
      document.head.appendChild(s);
    })();

    function applyAll() {
      const text = el.txt.value ?? "";

      // Vars
      const intensity = parseFloat(el.intensity.value);
      const speed = parseFloat(el.speed.value);
      const glitch = parseInt(el.glitch.value, 10);
      const blur = parseFloat(el.blur.value);
      const spread = parseInt(el.spread.value, 10);

      setCSSVar("--intensity", intensity);
      setCSSVar("--speed", speed);
      setCSSVar("--glitch", glitch + "px");
      setCSSVar("--blur", blur + "px");
      setCSSVar("--spread", spread + "px");

      el.intVal.textContent = intensity.toFixed(2);
      el.spdVal.textContent = speed.toFixed(2) + "×";
      el.glVal.textContent = glitch + "px";
      el.blVal.textContent = blur.toFixed(2) + "px";
      el.spVal.textContent = spread + "px";

      const jitter = parseFloat(el.letterJitter.value);
      const animAmt = parseFloat(el.letterAnim.value);
      el.jitVal.textContent = jitter.toFixed(2) + "px";
      el.lanVal.textContent = animAmt.toFixed(2);

      // Colors
      const fg = el.fg.value;
      const accent = el.accent.value;
      const bg = el.bg.value;

      setCSSVar("--fg", fg);
      setCSSVar("--accent", accent);
      setCSSVar("--bg2", bg);

      el.fgHex.textContent = fg.toLowerCase();
      el.acHex.textContent = accent.toLowerCase();
      el.bgHex.textContent = bg.toLowerCase();

      // Apply bg
      el.shell.style.background = `linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.32)), radial-gradient(800px 480px at 50% 20%, ${accent}22, transparent 60%), ${bg}`;

      // Classes
      const checked = getChecked();

      // Ensure fx-perletter toggle follows dropdown (if dropdown != none)
      const perLetterOn = el.letterPalette.value !== "none";
      const perLetterInput = el.effects.querySelector(`input[value="fx-perletter"]`);
      if (perLetterInput) perLetterInput.checked = perLetterOn;

      // Preview classes
      const basePreview = ["preview", "fx-smooth"];
      el.preview.className = [...basePreview, ...checked.preview].join(" ");

      // Shell classes
      el.shell.className = ["preview-shell", ...checked.shell].join(" ");

      // Glitch pseudo layers need data-text (plain text)
      el.preview.setAttribute("data-text", text);

      // Render: per-letter HTML or plain text
      const paletteKey = el.letterPalette.value;
      const mode = el.letterMode.value;

      if (perLetterOn) {
        const html = buildPerLetterHTML(text, paletteKey, mode, jitter, animAmt);
        el.preview.innerHTML = html ?? escapeHtml(text);
        // store per-letter in data-text anyway
      } else {
        el.preview.textContent = text;
      }

      // Fix lBob jitter transform composition: store random offsets in CSS vars so animation keeps them
      if (perLetterOn && jitter > 0) {
        el.preview.querySelectorAll(".ql").forEach(span => {
          const t = span.style.transform || "";
          // parse translate(x,y) if present; stash in vars
          const m = t.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
          const x = m ? m[1] : "0";
          const y = m ? m[2] : "0";
          span.style.setProperty("--tx", x + "px");
          span.style.setProperty("--ty", y + "px");
          // remove direct transform so keyframes controls it (but keeps tx/ty)
          span.style.transform = "";
        });
      } else if (perLetterOn) {
        el.preview.querySelectorAll(".ql").forEach(span => {
          span.style.setProperty("--tx", "0px");
          span.style.setProperty("--ty", "0px");
        });
      }

      // Typewriter chars estimation
      const chars = Math.max(1, text.replace(/\s+/g, " ").trim().length);
      el.preview.style.setProperty("--chars", String(clamp(chars, 6, 120)));

      // Info
      el.classList.textContent = "classes: " + [...checked.shell, ...checked.preview].join(" ");
      el.themeInfo.textContent = `${fg.toLowerCase()} / ${accent.toLowerCase()} / ${bg.toLowerCase()}`;
      el.charInfo.textContent = (text.length) + " chars";

      // Snippet
      const htmlSnippet =
        `<div class="preview-shell ${checked.shell.join(" ")}" style="--fg:${fg};--accent:${accent};--intensity:${intensity};--speed:${speed};--glitch:${glitch}px;--blur:${blur}px;--spread:${spread}px;background:${bg};">
  <div class="stage">
    <div class="preview fx-smooth ${checked.preview.join(" ")}" data-text="${escapeAttr(text)}">${perLetterOn ? "[per-letter spans...]" : escapeHtml(text)}</div>
  </div>
</div>`;

      const note =
        `/* Per-letter colors:
   - Turn on fx-perletter and render spans in JS (see buildPerLetterHTML).
   - LETTER_PALETTES is an array-of-palettes (palettes[] -> colors[]).
*/`;

      el.snippet.textContent = htmlSnippet + "\n\n" + note;
    }

    async function copy(text) {
      try {
        await navigator.clipboard.writeText(text);
        el.copied.style.display = "inline-flex";
        el.copied.textContent = "Copied";
        clearTimeout(copy._t);
        copy._t = setTimeout(() => el.copied.style.display = "none", 900);
      } catch {
        el.copied.style.display = "inline-flex";
        el.copied.textContent = "Copy failed";
        clearTimeout(copy._t);
        copy._t = setTimeout(() => el.copied.style.display = "none", 1100);
      }
    }

    function exportHTMLOnly() {
      const checked = getChecked();
      const text = el.txt.value ?? "";
      const fg = el.fg.value, accent = el.accent.value, bg = el.bg.value;
      const intensity = parseFloat(el.intensity.value);
      const speed = parseFloat(el.speed.value);
      const glitch = parseInt(el.glitch.value, 10);
      const blur = parseFloat(el.blur.value);
      const spread = parseInt(el.spread.value, 10);

      const perLetterOn = el.letterPalette.value !== "none";
      const paletteKey = el.letterPalette.value;
      const mode = el.letterMode.value;
      const jitter = parseFloat(el.letterJitter.value);
      const animAmt = parseFloat(el.letterAnim.value);

      const inner = perLetterOn
        ? (buildPerLetterHTML(text, paletteKey, mode, jitter, animAmt) ?? escapeHtml(text))
        : escapeHtml(text);

      return `<div class="preview-shell ${checked.shell.join(" ")}" style="--fg:${fg};--accent:${accent};--intensity:${intensity};--speed:${speed};--glitch:${glitch}px;--blur:${blur}px;--spread:${spread}px;background:${bg};">
  <div class="stage">
    <div class="preview fx-smooth ${checked.preview.join(" ")}" data-text="${escapeAttr(text)}">${inner}</div>
  </div>
</div>`;
    }

    function exportCSSAll() {
      const css = document.querySelector("style").textContent || "";
      return css.trim();
    }

    function randFrom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function randomize() {
      const paletteKeys = Object.keys(PALETTES).filter(k => k !== "custom");
      const p = PALETTES[randFrom(paletteKeys)];
      el.fg.value = p.fg;
      el.accent.value = p.accent;
      el.bg.value = p.bg;

      el.intensity.value = (Math.random() * 0.9 + 0.1).toFixed(2);
      el.speed.value = (Math.random() * 2.2 + 0.4).toFixed(2);
      el.glitch.value = Math.floor(Math.random() * 26);
      el.blur.value = (Math.random() * 5).toFixed(2);
      el.spread.value = Math.floor(Math.random() * 34);

      // random per-letter settings
      const letterKeys = ["none", ...Object.keys(LETTER_PALETTES)];
      el.letterPalette.value = randFrom(letterKeys);
      el.letterMode.value = randFrom(["cycle", "gradient"]);
      el.letterJitter.value = (Math.random() * 3).toFixed(2);
      el.letterAnim.value = (Math.random() * 0.8).toFixed(2);

      // Random effect toggles
      const inputs = el.effects.querySelectorAll('input[type="checkbox"]');
      inputs.forEach(i => i.checked = false);

      // Choose 3-7 effects
      const fxPool = EFFECTS.map(x => x.id);
      const keep = new Set();
      keep.add("crt");
      const count = Math.floor(Math.random() * 5) + 3;
      while (keep.size < count) {
        keep.add(randFrom(fxPool));
      }

      // Keep per-letter consistent with dropdown
      if (el.letterPalette.value !== "none") keep.add("fx-perletter");
      keep.forEach(id => {
        const input = el.effects.querySelector(`input[value="${CSS.escape(id)}"]`);
        if (input) input.checked = true;
      });

      applyAll();
    }

    // Palette changes
    el.paletteSelect.addEventListener("change", (e) => {
      const key = e.target.value;
      applyPalette(key);
      applyAll();
    });

    // Bind inputs
    ["input", "change", "keyup"].forEach(evt => el.txt.addEventListener(evt, applyAll));
    [el.fg, el.accent, el.bg, el.intensity, el.speed, el.glitch, el.blur, el.spread].forEach(x => {
      x.addEventListener("input", applyAll);
      x.addEventListener("change", applyAll);
    });
    [el.letterPalette, el.letterMode, el.letterJitter, el.letterAnim].forEach(x => {
      x.addEventListener("input", applyAll);
      x.addEventListener("change", applyAll);
    });

    el.copyCss.addEventListener("click", () => copy(exportCSSAll()));
    el.copyHtml.addEventListener("click", () => copy(exportHTMLOnly()));
    el.randomize.addEventListener("click", randomize);

    // Init UI
    (function initEffectsUI() {
      const frag = document.createDocumentFragment();
      EFFECTS.forEach((fx) => {
        const wrap = document.createElement("label");
        wrap.className = "check";
        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = fx.id;
        input.checked = DEFAULT_ON.has(fx.id);
        if (fx.id === "fx-perletter") input.checked = false;
        input.addEventListener("change", applyAll);

        const span = document.createElement("span");
        span.textContent = fx.label;

        wrap.appendChild(input);
        wrap.appendChild(span);
        frag.appendChild(wrap);
      });
      el.effects.appendChild(frag);
    })();

    (function initSwatches() {
      const frag = document.createDocumentFragment();
      SWATCHES.forEach((hex) => {
        const b = document.createElement("button");
        b.className = "swatch";
        b.type = "button";
        b.style.background = hex;
        b.title = hex;
        b.addEventListener("click", () => {
          el.accent.value = hex;
          applyAll();
        });
        frag.appendChild(b);
      });
      el.swatches.appendChild(frag);
    })();

    applyPalette("qud-emerald");
    applyAll();
  </script>
</body>

</html>